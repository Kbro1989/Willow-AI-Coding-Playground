import { Buffer } from 'buffer';
import { nexusBus } from '../nexusCommandBus';
import { ModelRequest, ModelResponse } from '../modelRouter';
import sessionService from '../sessionService';
import { EngineCache, ThreejsSceneCache, modelToThree } from './3d/modeltothree';
import { WasmGameCacheLoader } from './cache/sqlitewasm';
import type { GameCacheLoader } from './cache/sqlite';
import { cacheMajors } from './constants';
import * as THREE from 'three';
import { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';

export type Process3DStage =
    | "SOURCE_DETECT"
    | "RSMV_DECODE"
    | "NORMALIZE"
    | "EXPORT"
    | "PERSIST"
    | "AI_ORCHESTRATE";

export interface ShaderNode {
    id: string;
    type: 'input' | 'math' | 'color' | 'output' | 'texture' | 'time' | 'multiply' | 'add' | 'sin' | 'lerp' | 'mix' | 'normal' | 'fresnel';
    label: string;
    position: { x: number; y: number };
    inputs: string[];
    outputs: string[];
    value?: string;
}

export interface ShaderEdge {
    id: string;
    from: string;
    fromOutput: string;
    to: string;
    toInput: string;
}

export async function orchestrateRSMV(request: ModelRequest): Promise<ModelResponse> {
    const startTime = Date.now();
    const abortController = new AbortController();
    const jobId = `rsmv-compile-${Math.random().toString(36).slice(2, 9)}`;

    const job = nexusBus.registerJob({
        id: jobId,
        type: 'rsmv_compile',
        description: `RSMV Compile: ${request.prompt}`,
        abortController,
        metadata: { stage: "INIT", modelId: request.prompt }
    });

    try {
        if (sessionService.isOverQuota()) {
            throw new Error("[NEXUS_QUOTA] Session hard cost limit reached.");
        }

        // Stage 1: Source Detect & Cache Init
        job.metadata.stage = "SOURCE_DETECT";
        console.log(`[RSMV_COMPILER] ${jobId} -> Stage: SOURCE_DETECT`);

        // We prefer WasmGameCacheLoader for browser environments, fallback to SQLite for Node
        const isBrowser = typeof window !== 'undefined';
        let rawLoader: any;
        if (isBrowser) {
            rawLoader = new WasmGameCacheLoader();
        } else {
            const { GameCacheLoader } = await import('./cache/sqlite');
            rawLoader = new GameCacheLoader();
        }
        const engineCache = await EngineCache.create(rawLoader);
        const sceneCache = await ThreejsSceneCache.create(engineCache);

        // Stage 2: Decode
        job.metadata.stage = "RSMV_DECODE";
        console.log(`[RSMV_COMPILER] ${jobId} -> Stage: RSMV_DECODE`);

        let modelId = parseInt(request.prompt);
        if (isNaN(modelId)) {
            // Handle named lookups or other prompt-based logic if needed
            throw new Error(`Invalid model ID: ${request.prompt}`);
        }

        const modelData = await sceneCache.getModelData(modelId);

        // Stage 3: Normalize / Convert to THREE
        job.metadata.stage = "NORMALIZE";
        console.log(`[RSMV_COMPILER] ${jobId} -> Stage: NORMALIZE`);

        const group = await modelToThree(sceneCache, modelData);

        // Stage 4: Export
        job.metadata.stage = "EXPORT";
        console.log(`[RSMV_COMPILER] ${jobId} -> Stage: EXPORT`);

        // Use GLTFExporter to create a blob/URL
        const exporter = new GLTFExporter();
        const gltf = await new Promise<ArrayBuffer>((resolve, reject) => {
            exporter.parse(group, (result) => resolve(result as ArrayBuffer), (err) => reject(err), { binary: true });
        });

        // Stage 5: Persist / Return
        job.metadata.stage = "PERSIST";
        console.log(`[RSMV_COMPILER] ${jobId} -> Stage: PERSIST`);

        const base64 = Buffer.from(gltf).toString('base64');

        return {
            modelUrl: "data:application/octet-stream;base64," + base64,
            model: `rsmv-${modelId}`,
            provider: "local-rsmv",
            latency: Date.now() - startTime
        };
    } catch (error: any) {
        console.error(`[RSMV_COMPILER] Error in job ${jobId}:`, error);
        throw error;
    } finally {
        nexusBus.completeJob(jobId);
    }
}

/**
 * Compiles a visual Shader Graph (AST) into optimized GLSL.
 */
export function compileShaderGraph(nodes: ShaderNode[], edges: ShaderEdge[]): string {
    let glslCode = `// Generated by Willow Procedural Engine\nprecision mediump float;\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform sampler2D u_mainTexture;\n\nvarying vec2 v_uv;\nvarying vec3 v_normal;\nvarying vec3 v_viewPosition;\n\n`;

    const variableMap = new Map<string, string>();
    let varCounter = 0;

    const resolveNode = (nodeId: string): string => {
        const node = nodes.find(n => n.id === nodeId);
        if (!node) return 'vec3(0.0)';

        if (variableMap.has(nodeId)) return variableMap.get(nodeId)!;

        const varName = `v_${node.type}_${varCounter++}`;
        let declaration = '';

        switch (node.type) {
            case 'color': {
                const r = parseInt(node.value?.slice(1, 3) || '00', 16) / 255;
                const g = parseInt(node.value?.slice(3, 5) || '00', 16) / 255;
                const b = parseInt(node.value?.slice(5, 7) || '00', 16) / 255;
                declaration = `vec3 ${varName} = vec3(${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)});`;
                break;
            }
            case 'time':
                declaration = `float ${varName} = u_time;`;
                break;
            case 'multiply':
            case 'add': {
                const inA = edges.find(e => e.to === nodeId && e.toInput === 'a');
                const inB = edges.find(e => e.to === nodeId && e.toInput === 'b');
                const valA = inA ? resolveNode(inA.from) : '1.0';
                const valB = inB ? resolveNode(inB.from) : '1.0';
                const op = node.type === 'multiply' ? '*' : '+';
                declaration = `vec3 ${varName} = ${valA} ${op} ${valB};`;
                break;
            }
            case 'mix':
            case 'lerp': {
                const mixA = edges.find(e => e.to === nodeId && e.toInput === 'a');
                const mixB = edges.find(e => e.to === nodeId && e.toInput === 'b');
                const mixT = edges.find(e => e.to === nodeId && e.toInput === 't');
                const valMixA = mixA ? resolveNode(mixA.from) : 'vec3(0.0)';
                const valMixB = mixB ? resolveNode(mixB.from) : 'vec3(1.0)';
                const valMixT = mixT ? resolveNode(mixT.from) : '0.5';
                declaration = `vec3 ${varName} = mix(${valMixA}, ${valMixB}, ${valMixT});`;
                break;
            }
            case 'sin': {
                const inX = edges.find(e => e.to === nodeId && e.toInput === 'x');
                const valX = inX ? resolveNode(inX.from) : 'u_time';
                declaration = `float ${varName} = sin(${valX});`;
                break;
            }
            case 'texture':
                declaration = `vec4 ${varName} = texture2D(u_mainTexture, v_uv);`;
                break;
            case 'normal':
                declaration = `vec3 ${varName} = normalize(v_normal);`;
                break;
            case 'fresnel': {
                const valFN = edges.find(e => e.to === nodeId && e.toInput === 'normal') ? resolveNode(edges.find(e => e.to === nodeId && e.toInput === 'normal')!.from) : 'normalize(v_normal)';
                declaration = `float ${varName} = pow(1.0 + dot(normalize(-v_viewPosition), ${valFN}), 3.0);`;
                break;
            }
        }

        if (declaration) {
            glslCode += `  ${declaration}\n`;
            variableMap.set(nodeId, varName);
            return varName;
        }
        return 'vec3(1.0)';
    };

    const outputNode = nodes.find(n => n.type === 'output');
    if (!outputNode) return glslCode + 'void main() { gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0); }';

    glslCode += 'void main() {\n';
    const colorInputEdge = edges.find(e => e.to === outputNode.id && e.toInput === 'color');
    const finalColor = colorInputEdge ? resolveNode(colorInputEdge.from) : 'vec3(0.5, 0.5, 0.5)';
    glslCode += `  gl_FragColor = vec4(${finalColor}, 1.0);\n}\n`;

    return glslCode;
}

/**
 * Specialized AI Orchestration for 3D/Media tasks.
 */
export async function processAIPipeline(type: 'nexus' | 'forge' | 'chronos', prompt: string): Promise<string> {
    // This will eventually call specialized reasoning agents.
    // For now, we delegate to a high-level system prompt.
    const sysPrompts = {
        nexus: "You are the Nexus Librarian. You find and categorize assets across games.",
        forge: "You are the Forge Master. You create and optimize 3D geometry and shaders.",
        chronos: "You are the Chronos Oracle. You analyze historical game trends and lore."
    };

    const request: ModelRequest = {
        type: 'text',
        prompt: `${sysPrompts[type]}\n\nUser Request: ${prompt}`,
        tier: 'premium'
    };

    const { modelRouter } = await import('../modelRouter');
    const response = await modelRouter.route(request);
    return ('content' in response ? response.content : 'AI Synthesis failed.') || 'No content returned.';
}
